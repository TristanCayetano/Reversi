import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;



public class GameBoard {

	private int size;
	private Stone stones[][];
	private int turn = 0;
	private Player player1, player2 = null;
	private Direction direction;

	/**
	 * Konstruktor für das Spielfeld
	 *
	 * @param size
	 *            die Größe des zu erstellenden Spielfeldes
	 */

	public GameBoard(int size) {
		this.size = size;
		stones = new Stone[size][size]; // Erstellen des steine Arrays
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				stones[i][j] = new Stone('_', j, i); // Das Array wird mit
			}
		}
	}

	public void setStart() {
		stones[size - 1][0].SetSymbol(' ');
		stones[size - 1][size - 1].SetSymbol(' '); // Die unteren Eckfelder
													// werden mit
		// Leerzeichen besetzt
		stones[size / 2 - 1][size / 2 - 1].SetSymbol('X');
		;
		stones[size / 2][size / 2].SetSymbol('X');
		stones[size / 2][size / 2 - 1].SetSymbol('O');
		stones[size / 2 - 1][size / 2].SetSymbol('O'); // Die Startsteine werden
														// gesetzt
	}

	/**
	 * Methode zum zeichnen des Spielfeldes in der Konsole
	 */

	public void draw() {
		String space = "";
		if (size > 9) { // Anpassung falls Nummerierung 2-stellig wird
			space = " ";
		}

		System.out.println();
		System.out.print("     " + space);
		for (int k = 0; k < size - 2; k++) { // "Deckel" des Spielfeldes
			System.out.print("_ ");
		}

		System.out.println();

		for (int i = 0; i < size; i++) { // Schleife für jede Zeile
			System.out.print(i + 1 + " "); // Nummerierung
			if (size > 9 && i < 9) {
				System.out.print(" ");
			}
			if (0 < i && i < size - 1) {
				System.out.print("|");
			} else {
				System.out.print(" ");
			}
			for (int j = 0; j < size; j++) { // Schleife für jedes Element der
												// Zeile
				System.out.print(stones[i][j].getSymbol());
				if (!(j == size - 1 && (i == 0 || i == size - 1))) {
					System.out.print("|");
				}
			}
			System.out.println();
		}
		System.out.println();
		System.out.print("   " + space);

		for (int c = 65; c < size + 65; c++) { // Koordinatenbelegung A-Z
			if (c < 91) {
				System.out.print((char) c + " ");
			} else {
				System.out.print((char) (c - 26) + "" + (char) (c - 26));
			}
		}
		System.out.println();
		System.out.println();
		
		turn++;
	}

	public void setStone(char symbol, int y, int x) {
		stones[x][y].SetSymbol(symbol);
		check(stones[x][y]);
	}

	/**
	 * Methode zum erstellen zweier Spieler
	 *
	 * @param name
	 *            der Name des Spielers
	 * @param difficulty
	 *            Schwierigkeitsgrad des Computers, bei Mensch = 0
	 */

	public void setPlayer(String name, int difficulty) {
		if (player1 == null) {
			if (difficulty == 0) {
				player1 = new Player(name, 'X');
			} else {
				player1 = new AI('X', difficulty);
			}
		} else if (difficulty == 0) {
			player2 = new Player(name, 'O');
		} else {
			player2 = new AI('X', difficulty);
		}
	}

	public int getSize() {
		return size;
	}

	public int getTurn() {
		return turn;
	}

	public Player getPlayer() {
		if (getTurn() % 2 == 0) {
			return player2;
		} else {
			return player1;
		}
	}

	public boolean isPossible(int x, int y) {
		return true;
	}

	public boolean hasOptions() {
		return true;
	}

	public boolean isRunning() {
		return false;
	}

	public boolean isWinner() {
		return false;
	}

	public void check(Stone master) { 
		for (Direction d : Direction.values()) {
			int j= checkDirection(master,master,d);
			     if(j > 0){
			        consume(master, d,j);		    	
			     }
		}
    	draw();
	}

	/**
	 * Funktionen um Nachbarsteine zu erhalten
	 *
	 * @return der Nachbarstein
	 */

	public Stone getNeighbour(Stone s, Direction d) {
		try {
			return stones[s.getX() + d.getX()][s.getY() + d.getY()];
		} catch (ArrayIndexOutOfBoundsException e) {
			return new Stone('_', -1, -1);
		}
	}
	/**
	 * überprüft ob Übernehmen in einer richtung möglich ist
	 *
	 * @return der Nachbarstein
	 */
	public int checkDirection(Stone master,Stone s,Direction d) {
	  if(getNeighbour(s, d).getSymbol()  == '_') {
			 return -stones.length;
	  }
	  else{
		  if(master.getSymbol() != getNeighbour(s, d).getSymbol()){
			  return checkDirection(master,getNeighbour(s,d),d) + 1;
		  }else{
			  return 0;
		  }
	  }
	}

	/**
	 *
	 * @param master
	 *            der Stein der den anderen übernimmt
	 * @param slave
	 *            der Stein der übernommen wird
	 */

	public void consume(Stone master, Direction d, int j) {
		Stone neighbour = getNeighbour(master, d);
		for (int i = 0; i < j; i++) {
			neighbour.turn();
			neighbour = getNeighbour(neighbour, d);
		}
	}
	/**
	 * Methode zum speichern des Boards
	 *
	 * @param file
	 *            Speicherdatei
	 * @throws IOException
	 *             falls die datei nicht existiert
	 */

	public void save(String file) throws IOException {
		try {
			PrintWriter writer = new PrintWriter(file, "UTF-8");
			for (int i = 0; i < size; i++) {
				writer.print(stones[i]); // Schleife für alle Spielsteine
				writer.println();
			}
			writer.print(player1.getDifficulty()); // die restlichen
													// Informationen
			writer.print(player1.getSymbol());
			writer.print(player1.getName());
			writer.print(player2.getDifficulty());
			writer.print(player2.getSymbol());
			writer.print(player2.getName());
			writer.print(turn);
			writer.close();
		} catch (IOException e) {
			throw e;
		}
	}

	/**
	 * Konstruktor zum laden des Boards
	 *
	 * @param file
	 *            Speicherdatei
	 * @throws IOException
	 *             falls die datei nicht existiert
	 */
	public GameBoard(String file) throws IOException {
		try (BufferedReader reader = Files.newBufferedReader(Paths.get(file), Charset.defaultCharset())) {
			size = reader.readLine().length();
			stones = new Stone[size][size];
			reader.reset();
			for (int i = 0; i < size; i++) {
				for (int j = 0; j < size; j++) {
					stones[i][j] = new Stone(reader.readLine().charAt(j), j, i); // Belegt
																					// die
																					// steine
																					// mit
																					// den
																					// ausgelesen
																					// Werten
				}
			}
			int d = Integer.valueOf(reader.readLine());
			if (d == 0) {
				player1 = new Player(reader.readLine(), reader.readLine().charAt(0)); // Belegung
																						// der
																						// Spieler
			} else {
				player1 = new AI(reader.readLine().charAt(0), d);
				player1.setName(reader.readLine());
			}
			d = Integer.valueOf(reader.readLine());
			if (d == 0) {
				player2 = new Player(reader.readLine(), reader.readLine().charAt(0));
			} else {
				player2 = new AI(reader.readLine().charAt(0), d);
				player2.setName(reader.readLine());
			}
			turn = Integer.valueOf(reader.readLine());
		} catch (IOException e) {
			throw e;
		}
	}
}
